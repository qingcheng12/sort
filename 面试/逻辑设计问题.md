# 1、冒泡排序是如何实现的? 

第一种是最简单的方法，不用考虑性能问题:

    比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
    对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
    针对所有的元素重复以上的步骤，除了最后一个。
    持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

所以设置一个外循环控制每次比较的此时。内循环进行比较，如第一次外循环也就是第一个元素需要比较n-1次，每次都是前一个和后一个比较，所以内循环每次只需要比较外层的前一个。  

``` C
int sort(int ins[]){
		bool flag = true;		
			for(int i=ins.length-1; i>0; i--){
				for(int j=0; j<i; j++){//每次到达最后一个i下标的前一个，然后和后一个比较
					if(ins[j]>ins[j+1]){
						int temp = ins[j+1];
						ins[j+1] = ins[j];
						ins[j] = temp;
					}
				}
			}
		return ins;	
}
``` 

第二种：如果这个序列是一个有序的，那么此时不用每个都进行比较，一旦比较的中间一次没有交换数据，说明这个序列已经是有序了。所以可以设置一个标志位。一旦一个循环比较没有交换，将标志位设置为false，跳出循环。

``` C
int sort2(int ins[], int len){
		bool flag = true;
		int length = len-1;
		while(flag){
			flag = false;
				for(int j=0; j< length; j++){
					if(ins[j]>ins[j+1]){
						int temp = ins[j+1];
						ins[j+1] = ins[j];
						ins[j] = temp;
						flag = true;
					}
				}
			length --;
		}	
		return ins;		
}
```  
第三种：如果有10万个数据需要进行冒泡排序，那么这个时候如果只有前面200个是无序的，后面的都是有序，而且都比前面200个无序的大。所只需要比较前面200然后排好序就可以了，上面的这种方法其实前面200个排好序后也就停止了，因为再排序就会跳出循环，但是上面的那种方法每次一个比较都要和200后面的数据进行比较。其实只需要比较前面200个数据就可以了。这样比较后面的数据就会带来时间的问题。所以我们每次排序都找到一个节点，这个节点的后面的数据就是已经排好了，不用比较的数据

``` C
int sort3(int ins[], int len){
		int flage = len-1;
		while(flage>0){
			int k = flage;//k来记录遍历的尾边界
			flage=0;
			
			for(int i=0; i<k; i++){
				if(ins[i] > ins[i+1]){
					int temp = ins[i+1];
					ins[i+1] = ins[i];
					ins[i] = temp;
					flage = i;//每次比较后将边界值重新设定，如果比较过程中没有执行这一行语句，说明已经完成了排序，和第二种方法一样
				}
			}
		}
		return null;	
	}
```  


# 2、迭代式快排算法是如何实现的？  
   首先在要排序的序列 a 中选取一个中轴值，而后将序列分成两个部分，其中左边的部分 b 中的元素均小于或者等于 中轴值，右边的部分 c 的元素 均大于或者等于中轴值，而后通过递归调用快速排序的过程分别对两个部分进行排序，最后将两部分产生的结果合并即可得到最后的排序序列。  
　　“基准值”的选择有很多种方法。最简单的是使用第一个记录的关键字值。但是如果输入的数组是正序或者逆序的，就会将所有的记录分到“基准值”的一边。较好的方法是随机选取“基准值”，这样可以减少原始输入对排序造成的影响。但是随机选取“基准值”的开销大。  
　　为了实现一次划分，我们可以从数组（假定数据是存在数组中）的两端移动下标，必要时交换记录，直到数组两端的下标相遇为止。为此，我们附设两个指针（下角标）i 和 j， 通过 j 从当前序列的有段向左扫描，越过不小于基准值的记录。当遇到小于基准值的记录时，扫描停止。通过 i 从当前序列的左端向右扫描，越过小于基准值的记录。当遇到不小于基准值的记录时，扫描停止。交换两个方向扫描停止的记录 a[j] 与 a[i]。 然后，继续扫描，直至 i 与 j 相遇为止。扫描和交换的过程结束。这是 i 左边的记录的关键字值都小于基准值，右边的记录的关键字值都不小于基准值。  
　　通过两个不相邻元素交换，可以一次交换消除多个逆序，加快排序速度。快速排序方法在要排序的数据已经有序的情况下最不利于发挥其长处。  
  
``` C
 int split(int data[],int low,int high)  
{  
    int i=low;  
    int x=data[low];  
    int tmp;  
    for(int j=low+1;j<=high;j++)  
    {  
        if(data[j]>x)  
        {   i++;  
            if(i!=j)   
            {  
                tmp=data[j];  
                data[j]=data[i];  
                data[i]=tmp;  
            }  
        }  
    }  
    tmp=data[low];  
    data[low]=data[i];  
    data[i]=tmp;  
    return i;  
} 

int quicksort(int data[],int s,int t)  
{  
      int i=s,j=t;  
      int tmp;  
      if(s<t)  
      {  
        tmp=data[s];  
        while(i!=j)  
        {  
          while(j>i&&data[j]<=tmp) j--;  
          data[i]=data[j];  
          while(i<j&&data[i]>=tmp) i++;  
          data[j]=data[i];             
        }  
        data[i]=tmp;  
        return i;  
      }  
}  

// 递归形式
void quicksort(int data[],int low,int high)  
{  
        if(low<high)  
        {  
            int w=split(data,low,high);  
            quicksort(data,low,w-1);  
            quicksort(data,w+1,high);  
        }  
}

// 迭代形式
// 递归转化为迭代算法的关键是传递每次划分的low和high，所以定义一个结构体st来存储每次划分的low和high，
// top初始为-1，用来记录长度。划分一次st长度++，进入划分一次st长度--，直到top=-1。
struct node  
{ 
    int low,high;  
}st[10000];  

void quicksort2(int data[],int s,int t)  
{  
        int top=-1,low,high;  
        top++;  
        st[top].low=s;
	st[top].high=t;  
        while(top>-1)  
        {  
            low=st[top].low;
	    high=st[top].high;  
            top--;  
            int w;  
            if(low<high)  
            {  
                w=split(data,low,high);//或者split2  
                st[++top].low=low;
		st[top].high=w-1;  
                st[++top].low=w+1;
		st[top].high=high;  
            }  
        }  
}  
``` 



# 3、你如何实现插入排序算法？  




# 4、合并排序算法是如何实现的？

# 5、桶排序算法是如何实现的？

# 6、计数排序算法是如何实现的？

# 7、基数排序算法是如何实现的？

# 8、在不使用第三个变量的前提下如何交换两个数？

异或位运算：  
异或：两个运算位，相同为0，不同为1。  

``` C
1 ^ 1 = 0;
0 ^ 0 = 0;
1 ^ 0 = 1;	// 交换运算位值不变，0 ^ 1 = 1
```   

原理： 一个数与另一个数异或两次，值不变。  

``` C
// 第一个运算位是初始值，第二第三个是异或两次的数
(1 ^ 0) ^ 0 = 1 ^ 0 = 1
(1 ^ 1) ^ 1 = 0 ^ 1 = 1
(0 ^ 1) ^ 1 = 1 ^ 1 = 0
(0 ^ 0) ^ 0 = 0 ^ 0 = 0
``` 

``` C
// 为了更直观地理解，我刻意加入了下标
int A1 = 2, B1 = 3;
A2 = A1 ^ B1;
B2 = A2 ^ B1 = A1 ^ B1 ^ B1 = A1;
A3 = A2 ^ B2 = A1 ^ B1 ^ A1 = B1;
``` 

# 9、如何检查两个矩形是否重叠？

# 10、如何设计一个自动售货机？
